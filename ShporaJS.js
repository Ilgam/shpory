/////////////////////Начало работы/////////////////////////////////////

window.onload = function(){ // Загрузка страницы завершина
}
/////////////////////Шаблон проектирования MVC/////////////////////////

var vies = {};// - Представления
var model = {};// - Модель
var controller = {};// - Контроллер
// 1.Пользователь взаимодействуент с приложением
// 2.Вызываются обработчики событий в контроллере
// 3.Кортроллер запрашивает данные из контроллера и передает их представленю
// 4.Предаставление предоставляет их пользователю

////////////////////////////////Var//////////////////////////////////////

var a = 'Zoom', // Строкеа
    b = 3,      // Число
    c = false,  // Булевые значение
    d = '',     // Постая перемекнная
    v;          // Переменная(Ее можно объявить как факт)
// 1. Все переменные наверху глобальные
// 2. Если переменныя определяется в функции то она локальная.
// 3. Все перемнные локальные если в начале файла .js стоит window.onload = function(){};
var a = 5;
console.log(typeof a) // Возвращает строку, указывающую тип операнда


////////////////////////////Проверка на число/////////////////////////////

// 1.NaN нерано ничему даже самому себе
// 2. isNaN возвращет true если переданное ей значение не число
isNaN("12") // Вернет false

////////////////////////////Из строки в число/////////////////////////////

var a = "2", // строка
    b = +a;  // число

/////////////////////Кое-что о функциях////////////////////////////////

function foo(ip){}; // Функции
foo();              // Вызов функции
(function foo(ip){
    console.log(ip)
})('cocis');        // Это способ при которой cocis передается аргументу ip,
                  // в этом примере в концол выедет cocis
// 1. Замыкание - функция и все ее внешнии переменные
// 2. Первокласные функции - функция в функции. Пример:
//                      function foo(){
//                                    function ggg(){};
//                       }

//////////////////////Генератор случайных чисел///////////////////////////
Math.floor(Math.random() * 5); // - генерирует случайные числа от 0 до 4(включительно)
//Math.random() - генерирует случайные число от 0 до 1(не включая 1), но дробные 0.123; 0.499
//Math.floor() - отбрасывает дробную часть то есть 0.123 в 0; 4.999 в 4;
Math.ceil() // Десятичное округление вверх
// Пример: использование
Math.ceil(.95);   // 1
Math.ceil(4);     // 4
Math.ceil(7.004); // 8

/////////////////////////////Строки///////////////////////////////////////

// Строки зачастую выступают ввиде массивов

var anyString = "Привет, мир"
console.log(anyString.charAt(0))         // Возвращает символ в строке,
                                         // в этом примере возвратиться - П

var LowerText="ПриВет"
document.write(LowerText.toLowerCase()); // Возвращает строку нижнего реестра,
                                         // в этом примере возвратиться привет
var upperText="ПриВет"
document.write(upperText.toUpperCase())  // Возвращает строку нижнего реестра,
                                         // в этом примере возвратиться ПРИВЕТ

var arr = [ 1, 2, 3, 4, 5 ];
arr.slice(2);                           // Данный метод не изменяет исходный массив или строку,
                                        // а просто возвращает его часть.
                                        // Здесь вернется - [3, 4, 5]
var str = "Моя строка"
str.substring(0,3)                      // Возвращает часть сточки, без последнего значения(здесь без 3),
                                        // в этом примере возвратиться Моя
var str = "тест еще тест";
str.replace("тест","прошел");           // Заменяет одну строк другой,
                                        // в этом примере возвратиться "прошел еще тест"
var str = "     Hello World!      ";
alert(str.trim());                      // Метод trim() удаляет пробельные символы с начала и конца строки,
                                        // в этом примере возвратиться "Hello World!"
var str1 = "Hello ";
var str2 = "world!";
var res = str1.concat(str2);            // Соединяет строки, здесь получиться Hello World!"
                                        // Также с массивами см ниже
var alpha = ["a", "b", "c"];
var numeric = [1, 2, 3];
var alphaNumeric = alpha.concat(numeric);// Создает массив ["a", "b", "c", 1, 2, 3];

var upperText="ПриВет"
document.write(upperText.toLowerCase()); // Возвращает строку нижнего реестра,
                                         // в этом примере возвратиться привет привет

///////////////////////////////Массивы (так же см строки)/////////////////

a = [1,2,45,12,5,34];
a[a.length -1];                          // Вернет последний элемент массива
a.push(3);                               // добавлние в конец массива нового новый элемент
for (var i = 0; i < this.numShip; i++) {
    var ship = this.a[i];
    var index = ship.location.indexOf(2); // Сравнивает значение и то что в кавычках
};                                        // и возвращает номер положения в массиве элемента,
                                          // в этом примере возвратиться - 1
                          // Работет так же и для строк
var array = [2, 5, 9];
array.indexOf(5);                         // Вернется 1

var arr = ["мой","маленький", "массив"]
var my = arr.shift() // удаление элемента массива с индексом, здесь => "мой"
alert(arr[0]) // => "маленький"
// теперь arr = ["маленький", "массив"]

myFish = ["angel", "clown", "mandarin", "surgeon"];// удаление элемента массива
popped = myFish.pop(); // теперь popped = "surgeon", a myFish = ["angel", "clown", "mandarin"]



/////////////////////////Цикл for, перебор массива/////////////////////////////

var a = [1,2,34,65,72,64];
for(var i = 0; i < a.length; i++){
    console.log(a[i]);
}
// length - длина массива
// еще один способ перебора
var go = [1232,43,64,12,445,7]
for(var item in go){
    console.log(item);
    console.log(go[item])
}

 var foo = [10,4,6,2,4]
 function foof(a,b){
     if(a < b){
        return 1;
    } else if(a == b ){
        return 0;
   } else {
       return -1;
   }
  }
foo.sort(foof);  // сортирует элементы массива
                 // в этом примере возвратиться [2,4,4,6,10]


////////////////////////////////Цыкл while///////////////////////////////////////

a= 0;
while ( a < 3 ){
   a++;
    };
// Пока a < 3 делать а + 1

do {
    locat = this.generetShip();  //делать
} while (this.collision(locat)); // пока

////////////////////////////////Цыкл in ///////////////////////////////////////

Car = {
    a: 'Zoom',
    b: 34,
    c: function () {
        console.log(this.a); // Не забываем про this
    }
};
for(var prop in car){   // Переберают свойства объекта и последовательно
                        // присваивает  переменной prop
    console.log(prop + ':' + car[prop]);  //prop с квадратными скобками можно
                                         // использовать для получение значений свойтв
}

///////////////////////////////Объекты///////////////////////////////////////

Car = {
    a: 'Zoom',
    b: 34,
    c: function() {
        console.log(this.a); // Не забываем про this
    },
    fist: function() {
            var foo = document.getElementById('zero');
            foo.onclick = Car.touth.bind(Car); // Обработчик события для объектов
        },                                     // сначала объект.ссылка на свойство.bind(объект)
    touth: function(eventObj){
        console.log('blabla');
    }
}
Car.d = false; // Добавление в объект или изменеие
delete Car.b;  // Удаление свойства объект
Car.c();       // Вызов свойства объетка с функцией
Car['a'];      // Обратиться объекту можно и так
o = new Object();
o.prop = 'существует';
o.hasOwnProperty('prop'); // Возвращает логическое значение, указывающее,
                          // содержит ли объект указанное свойство,
                          // в этом примере возвратиться true

//////////////////////////Конструктор Объектов ///////////////////////////////
// Пример 1
function Dog(name, old) {
    this.name = name;
    this.old = old;
    this.cons = function () {
        console.log('Это объкект - ' + this.name);
    }
}
  var Kevin = new Dog('Kevin','34'); // Получиться объект Kevin
// Пример 2
  function Car(p){
    this.name = p.name;
    this.model = p.model;
    this.god = p.old;
};
var Cadi = new Car({                 // Получиться объект Cadi
    name: 'Cadi',
    model: 'Cadilac',
    old: '1999'
});

if(Cadi instanceof  Car) {            // Возвращает true если объект был создан указанным конструктором
}

//////////////////////////////Прототипы///////////////////////////////////////

//Объекты могут наследовать свойства от других объектов через прототипы и конструктор
function Dog(name, old) {
    this.name = name;
    this.old = old;
    this.cons = function () {
        console.log('Это объкект - ' + this.name);
    }
}
var Kevin = new Dog('Kevin','34');
    Dog.prototype.say = function(){  // Теперь Kevin может унаследовать свойсто .say,
      console.log("Gav");            // достаточно прописать  Kevin.say
  }

    function Robot(name,old) {
        this.name = name;
        this.old = old;
    }
    Robot.prototype.toString = function(){ // Мы переопределили метод toString специально для Robot  (toString и toLocaleString Преобразуют значение свойст в строку в строку)
        return this.name + this.old
    }
    var Gavi = new Robot('Gavi','34');
    console.log(Gavi.toString());

////////////////////Цепочка прототипов конструкторов//////////////////////////
function Dog1(name,old,test1){
    this.name = name;
    this.old = old;
    this.test1 = function(){
        console.log('test1');
    }
}
function Dog2(test2){
    this.test2 = function(){
        console.log('test2');
    }
}
Dog2.prototype = new Dog1(); // Вот конструктор Dog2 унаследует свойства от конструтора Dog1
function Dog3(name,old,test3){
    Dog1.call(this,name,old); // чтобы не писать this.name = name; this.old = old; можно их вызвать из Dog1
    this.test3 = function(){
        console.log('test3');
    }
}
Dog3.prototype = new Dog2(); // Вот конструктор Dog3 унаследует свойства от конструтора Dog2
var Kevin = new Dog3('Kevin','34');
console.log(Kevin.constructor); // .constructor определит изначальный конструктор

///////////////////Переопределение свойст встроенных объектов/////////////////

// В этом примере переопределено свойство объета строк
String.prototype.ooo = function(){
        var na = ['0'];
            var index = this.indexOf(na[0]);
            if (index == 0) {
                return true;
        }
        return false;
    }
var ff = 'fdgwdf0xcvxcv0000er';
    for (var i = 0; i < ff.length; i++){
        var fsss = ff[i];
        if(fsss.ooo()){
            console.log(fsss);
        }
    }

//////////////////////////Взаимодействие с HTML///////////////////////////////

document.getElementById('');         // По id
document.getElementsByClassName(''); // По class
document.getElementsByName('');      //Он работает только с теми элементами, для которых в спецификации явно
                                     // предусмотрен атрибут name: это form, input, a, select, textarea
document.getElementsByTagName('');   // По тегу: p, img, div, ul, li и т д
document.querySelector('');          // сбда можно без конфликтов засунуть как id так и class что удобно
                                     // только в начале нудно писать точку или решетку пример querySelector('.page_canvas')
var a = document.getElementById('foo');
    a.setAttribute('class', 'ufa');   // Вызывается для задания атрибутов элементов HTML,
                                     // В данном случае элементу добавляется класс  ufa
var b = document.getElementById('faa');
    g = b.getAttribute('class');     // Узнать значение атрибута элемента,
                                     // В данном случае какой класс у элемента faa
    b.removeAttribute('class');      // удалить атрибут

var image = document.getElementsByTagName('img');
    image.src = "bls.jpg";           // Вставляет в атрибут src ссылку на фаил
var elem.getBoundingClientRect();   // возвращает размер элемента и его позицию относительно окна.

children                             // – только дочерние узлы-элементы, то есть соответствующие тегам.
firstElementChild, lastElementChild  //– соответственно, первый и последний дети-элементы.
previousElementSibling, nextElementSibling //– соседи-элементы.
    parentElement                    //– родитель-элемент.
element.style                        // возвращает объект, который дает доступ к стилю элемента на чтение и запись.
var a = document.getElementById('foo');
a.style.width="5px".                 // здесь доюавиться ширина в 5рх
    // свойства css где есть черточка в js преобразуются в
elem.style.backgroundColor
elem.style.zIndex
elem.style.borderLeftWidth
offsetWidth                           //внешняя ширина блока (т.е. со всеми падингами и марджинами),
offsetHeight                         //  внешняя высота блока.
elem.innerHTML                        // вставить текст
var div = document.createElement('div'); // Создает новый элемент с указанным тегом
div.className ="success";             // присваивают класс
div.appendChild(elem);                // Добавляет elem в конец дочерних элементов div
                                      // пример
var newLi = document.createElement('li');
newLi.innerHTML = 'Привет, мир!';
list.appendChild(newLi);

div.insertBefore(elem, nextSibling)   // Вставляет elem в коллекцию детей parentElem, перед элементом nextSibling.
                                      // пример
var newLi = document.createElement('li');
newLi.innerHTML = 'Привет, мир!';
list.insertBefore(newLi, list.children[1]);

parentElem.insertBefore(elem, null);
// то же, что и:
parentElem.appendChild(elem)

div.querySelector('li')                // возвращает только первый элемент. Этот метод часто используется,
  // когда мы заведомо знаем, что подходящий элемент только один, и хотим получить в переменную сразу его.
parentElem.removeChild(elem)          // удлаление в родительском элементе  parentElem, элемент elem
parentElem.replaceChild(newElem, elem)// Среди детей parentElem удаляет elem и вставляет на его место newElem.
                                   // переместить элемент на новое место
    //<div>Первый</div
    // <div>Второй</div>
var first = document.body.children[0];
var last = document.body.children[1];
// нет необходимости в предварительном removeChild(last)
document.body.insertBefore(last, first) // поменять местами

//Итого
//Методы для создания узлов:
document.createElement(tag) // создает элемент
document.createTextNode(value) // создает текстовый узел
elem.cloneNode(deep) // клонирует элемент, если deep == true, то со всеми потомками, если false – без потомков.


// Вставка и удаление узлов:
parent.appendChild(elem)
parent.insertBefore(elem, nextSibling)
parent.removeChild(elem)
parent.replaceChild(newElem, elem)
elem.remove()   // - удаление элемента напрямую
/////////////////////////////Обработчики событий////////////////////////////////

// Здесь нужно обратить внимание на .target и .id и на свойство функции blabla(здесь eventObj)
var foo = document.getElementsByClassName('zero');
    for (var i = 0; i < foo.length; i++) {
        foo[i].onclick = function (eventObj) { // При обработки событий
                                               // свойство функции blabla(здесь eventObj) ОБЕЗАТЕЛЬНО
            var img = eventObj.target,         // Свойство target определяет какой элемент сгенерировал данное событие
                name = img.id;                 // Определяет значение id элемента
        };
    }
var button = document.getElementsByClassName('depo');
button.addEventListener('click', function(){}, false); // Еще один способ добавление обработчика событий
                                                       // АddEventListener() получает тип события(из таблицы только убрать on),
                                                       // функцию и аргумент(false - важно так как получает фазу сплытия - важная штука)
button.removeEventListener('click', function(){})      // Удаление  обработчика событий

function reblur(img){
    console.log('blabla');
}
setTimeout(reblur, 1000, img); // ожидания в 1 секунду, потом запускается функция, в которую
                               // передается аргумент img(можно и без него)
function ulo(){
    console.log('blabla');
}
/// в цикле//
function animate() {
    for (i = 0; i <= 10; i++) {
        (function(m) {
            setTimeout(function() {
                document.write(m);
            }, 100 * (i + 1))
        })(i);
    };
}
animate();
//////////


setInterval(ulo, 1000);        // счетчик, функция запускается чекрез каждую секунду
// начать повторы с интервалом 2 сек
var timerId = setInterval(function() {
    alert( "тик" );
}, 2000);

// через 5 сек остановить повторы
setTimeout(function() {
    clearInterval(timerId);
    alert( 'стоп' );
}, 5000);

var t = this;
this.op = setInterval(function(){t.setIn()}, 1000); // setInterval в объекте
clearInterval(this.op);                              // clearInterval в объекте
var frr = document.getElementById('zее');
    frr.onmousemove = function(ooo) {
        var a = ooo.pageX, // смещение в пикселях от левого края страницы браузера
            b = ooo.pageY; // смещение в пикселях от верхнего края страницы браузера
        console.log(a + "," + b);
    }
// Еще есть, но я их не рассматривал
 // offsetX offsetY - внутри дива
// clientX clientY - смещение в пикселях от левого верхнего края окна браузера
// screenX screenY - смещение в пикселях от левого верхнего края пользовательского экрана
offsetParent              // – «родитель по дереву рендеринга» – ближайшая ячейка таблицы,
                         // body для статического позиционирования или ближайший позиционированный
                         // элемент для других типов позиционирования.
offsetLeft/offsetTop     // – позиция в пикселях левого верхнего угла блока,
                         // относительно его offsetParent.
offsetWidth/offsetHeight // – «внешняя» ширина/высота блока, включая рамки.
clientLeft/clientTop      //– отступ области содержимого от левого-верхнего угла элемента.
                         // Если операционная система располагает вертикальную прокрутку справа,
                         // то равны ширинам левой/верхней рамки, если же слева,
                         // то clientLeft включает в себя прокрутку.
clientWidth/clientHeight // – ширина/высота содержимого вместе с полями padding,
                         // но без полосы прокрутки.
scrollWidth/scrollHeight //– ширина/высота содержимого, включая прокручиваемую область.
                        // Включает в себя padding и не включает полосы прокрутки.
scrollLeft/scrollTop    //– ширина/высота прокрученной части документа, считается
                        // от верхнего левого угла.
var gInput = document.getElementById('InputText'),
    getIn = gInput.value;        // Берет значение из INPUT, TEXTAREA
var Inpu = document.getElementById('InputText'),
    gIn = Inpu.value,
    Pi = parseInt(gIn );         //  принимает строку в качестве аргумента и возвращает целое число

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//ОРАБОТЧИК  //  ПОДДЕРЖИВАЮЩИЕ HTML-элементы //      ОПИСАНИЕ                                            //
//СОБЫТИЯ    //                               //                                                          //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onClick	 //   все HTML-элементы	          //      Одинарный щелчок (нажата и отпущена кнопка мыши)    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onAbort	 //  IMG	                      //      Прерывание загрузки изображения                     //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onBlur	 //  A, AREA, BUTTON, INPUT, LABEL//                                                          //
//           //    SELECT, TEXTAREA	          //      Потеря текущим элементом фокуса, т.е.               //
//           //                               //      переход к другому элементу.                         //
//           //                               //      Возникает при щелчке мышью вне элемента             //
//           //                               //      либо нажатии клавиши табуляции                      //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onChange	 //   INPUT, SELECT, TEXTAREA	  //      Изменение значений элементов формы.                 //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onDblClick //	  все HTML-элементы           //      Двойной щелчок                                      //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onError	 //   IMG, WINDOW	              //      Возникновение ошибки выполнения сценария            //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onFocus	 //  A, AREA, BUTTON, INPUT,      //                                                          //
//           //   LABEL, SELECT, TEXTAREA     //      Получение элементом фокуса                          //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onKeyDown	 //    все HTML-элементы          //      Нажата клавиша на клавиатуре                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onKeyPress //	все HTML-элементы	          //      Нажата и отпущена клавиша на клавиатуре             //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onKeyUp	 //   все HTML-элементы	          //      Отпущена клавиша на клавиатуре                      //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onLoad	 //   BODY, FRAMESET	          //      Закончена загрузка документа                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onMouseDown//	все HTML-элементы	          //      Нажата кнопка мыши в пределах текущего элемента     //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onMouseMove//	все HTML-элементы	          //      Перемещение курсора мыши в пределах текущего элемена//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onMouseOut //	и все HTML-элементы           //  	  Курсор мыши выведен за пределы текущего элемента    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onMouseOver//	 все HTML-элементы            //      Курсор мыши наведен на текущий элемент              //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onMouseUp	 //   все HTML-элементы	          //      Отпущена кнопка мыши в пределах текущего элемента   //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onMove	 //  WINDOW	                      //      Перемещение окна                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onReset	 //  FORM	                      //      Сброс данных формы ( щелчок по кнопке               //
//           //                               //        <input type="reset"> )                            //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onResize	 // WINDOW	                      //      Изменение размеров окна                             //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onSelect	 // INPUT, TEXTAREA	              //      Выделение текста в текущем элементе                 //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onSubmit	 // FORM	                      //      Отправка данных формы ( щелчок по кнопке            //
//           //                               //       <input type="submit"> )                            //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//onUnload	 // BODY, FRAMESET	              //      Попытка закрытия окна браузера и выгрузки документа //
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////все втрибуты импута//////////////////////////////////


//     accept
//Устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов.
//    accesskey
//Переход к элементу с помощью комбинации клавиш.
//    align
//Определяет выравнивание изображения.
//    alt
//Альтернативный текст для кнопки с изображением.
//    autocomplete
//Включает или отключает автозаполнение.
//    autofocus
//Устанавливает фокус в поле формы.
//    border
//Толщина рамки вокруг изображения.
//    checked
//Предварительно активированный переключатель или флажок.
//    disabled
//Блокирует доступ и изменение элемента.
//    form
//Связывает поле с формой по её идентификатору.
//    formaction
//Определяет адрес обработчика формы.
//    formenctype
//Устанавливает способ кодирования данных формы при их отправке на сервер.
//    formmethod
//Сообщает браузеру каким методом следует передавать данные формы на сервер.
//    formnovalidate
//Отменяет встроенную проверку данных на корректность.
//    formtarget
//Определяет окно или фрейм в которое будет загружаться результат, возвращаемый обработчиком формы.
//    list
//Указывает на список вариантов, которые можно выбирать при вводе текста.
//    max
//Верхнее значение для ввода числа или даты.
//    maxlength
//Максимальное количество символов разрешенных в тексте.
//    min
//Нижнее значение для ввода числа или даты.
//    multiple
//Позволяет загрузить несколько файлов одновременно.
//    name
//Имя поля, предназначено для того, чтобы обработчик формы мог его идентифицировать.
//    pattern
//Устанавливает шаблон ввода.
//    placeholder
//Выводит подсказывающий текст.
//    readonly
//Устанавливает, что поле не может изменяться пользователем.
//    required
//Обязательное для заполнения поле.
//    size
//Ширина текстового поля.
//    src
//Адрес графического файла для поля с изображением.
//    step
//Шаг приращения для числовых полей.
//    tabindex
//Определяет порядок перехода между элементами с помощью клавиши Tab.
//    type
//Сообщает браузеру, к какому типу относится элемент формы.
//    value
//Значение элемента.
/////////////////////все типы type//////////////////////////////////////
button	//Кнопка.
checkbox //Флажки. Позволяют выбрать более одного варианта из предложенных.
file	//Поле для ввода имени файла, который пересылается на сервер.
hidden	//Скрытое поле. Оно никак не отображается на веб-странице.
image	//Поле с изображением. При нажатии на рисунок данные формы
// отправляются на сервер.
password //Обычное текстовое поле, но отличается
// от него тем, что все символы показываются звездочками.
// Предназначено для того, чтобы никто не подглядел вводимый пароль.
radio	//Переключатели. Используются, когда следует выбрать один
// вариант из нескольких предложенных.
reset	//Кнопка для возвращения данных формы в первоначальное значение.	Сбросить
submit	//Кнопка для отправки данных формы на сервер.	Отправить
text	//Текстовое поле. Предназначено для ввода символов с помощью клавиатуры.

//////////////////////В HTML5 добавлены новые значения///////////////////////
color	//Виджет для выбора цвета.
date	//Поле для выбора календарной даты.
datetime//	Указание даты и времени.
datetime-local//	Указание местной даты и времени.
email	//Для адресов электронной почты.
number	//Ввод чисел.
range	//Ползунок для выбора чисел в указанном диапазоне.
search	//Поле для поиска.
tel	     //Для телефонных номеров.
time	//Для времени.
url	   //Для веб-адресов.
month	//Выбор месяца.
week	//Выбор недели.


/////////////////////////////CANVAS////////////////////////////////


var example = document.getElementById("example"),
    ctx     = example.getContext('2d');                // Так объявляется канвас, обязательно ставим ширину и высоту
                                                      // В HTML обязательно ставим
                                                      // <canvas height='320' width='480' id='example'>Обновите браузер</canvas>
/////////////////////////////Прямоугольники////////////////////////////////

strokeRect(x, y, ширина, высота) // Рисует прямоугольник
fillRect(x, y, ширина, высота)   // Рисует закрашенный прямоугольник
clearRect(x, y, ширина, высота)  // Очищает область на холсте размер с прямоугольник заданного размера
beginPath()                      //  используется что бы «начать» серию действий описывающих отрисовку фигуры.
closePath()                      //  является не обязательным действием и по сути оно пытается завершить рисование
stroke()                         // обводит фигуру линиями
fill()                           // заливает фигуру сплошным цветом

moveTo(x, y) // перемещает "курсор" в позицию x, y и делает её текущей
lineTo(x, y) // ведёт линию из текущей позиции в указанную, и делает в последствии указанную текущей
arc(x, y, radius, startAngle, endAngle, anticlockwise) // рисование дуги, где x и y центр окружности,
             // далее начальный и конечный угол, последний параметр указывает направление
//////////////////////////////////круг//////////////////////////////////////
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI*2, false);// (точка серидины х, точка серидины у, радиус,Начальный угол окружности;
                                            // Конечный угол окружности;
                                            // Направление прорисовки (false – по часовой стрелке) )
ctx.fill()

/////////////////////////////Рисование Короны////////////////////////////////
var example = document.getElementById("example"),
    ctx     = example.getContext('2d');
example.height = 480;
example.width  = 640;
ctx.beginPath();
ctx.arc(80, 100, 56, 3/4 * Math.PI, 1/4 * Math.PI, true);
ctx.fill(); // *14
ctx.moveTo(40, 140);
ctx.lineTo(20, 40);
ctx.lineTo(60, 100);
ctx.lineTo(80, 20);
ctx.lineTo(100, 100);
ctx.lineTo(140, 40);
ctx.lineTo(120, 140);
ctx.stroke(); // *22
// В строке 14 заливается цветом дуга, в строке 22 обводится контур нашей короны.

fillStyle = color   // определяет цвет заливки
strokeStyle = color // цвет линий цвет задается точно так же как и css,
                    // на примере все четыре способа задания цвета
ctx.fillStyle = "orange";
ctx.fillStyle = "#FFA500";
ctx.fillStyle = "rgb(255,165,0)";
ctx.fillStyle = "rgba(255,165,0,1)"

/////////////////////////////Рисование шахматной доски////////////////////////////////

var example = document.getElementById("example"),
    ctx     = example.getContext('2d');
ctx.beginPath();
example.height = 480;
example.width  = 640;
ctx.strokeStyle = '#B70A02'; // меняем цвет рамки
ctx.strokeRect(15, 15, 266, 266); // внешняя рамка
ctx.strokeRect(18, 18, 260, 260); // внутреняя рамка
ctx.fillStyle = '#AF5200'; // меняем цвет клеток
ctx.fillRect(20, 20, 256, 256); // заливаем квардат чтобы там вырезать клетки
for (i = 0; i < 8; i += 2)
    for (j = 0; j < 8; j += 2) {
        ctx.clearRect(20 + i * 32, 20 + j * 32, 32, 32);
        ctx.clearRect(20 + (i + 1) * 32, 20 + (j + 1) * 32, 32, 32);

    }
///////////////////////лопата канваса чтобы изменялся и не повторялоаськартинка////////
imgh.addEventListener('change', imgWH, false)

function imgWH(){
    canvas.width = canvas.width; /// - вот лопата
    ctx.drawImage(img, 0,0, imgw.value,imgh.value);
}
/////////////////////////////Изображение////////////////////////////////

var example = document.getElementById("example"),
    ctx       = example.getContext('2d'),               // Контекст
    pic       = new Image();                           // "Создаём" изображение
pic.src    = 'http://habrahabr.ru/i/nocopypast.png';  // Источник изображения, позаимствовано на хабре
pic.onload = function() {                            // Событие onLoad, ждём момента пока загрузится изображение
    ctx.drawImage(pic, 0, 0);                       // Рисуем изображение от точки с координатами 0, 0
}
drawImage(image, x, y, width, height)  //  параметры width, height меняют ширину и высоту изображения
drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);// Первый параметр указывает на изображение
// sx, sy, sWidth, sHeight указывают параметры фрагмента на изображение-источнике
// dx, dy, dWidth, dHeight ответственны за координаты отрисовки фрагмента на холсте
getImageData(sx, sy, sw, sh)// Метод возвращает данные о цвете (RGB)
                            // и прозрачности указанного участка холста.
                            //sx и sy — координаты левого верхнего угла прямоугольника;
                            //sw — ширина участка;
                            //sh — высота участка.
//Данные вернуться одномерным массивом размером 4xswxsh, один пиксель будет включать 4 цвета
// (кпассный, зеленый, голубой, альфа-значение прозрачности )
// поэтому ширину и высоту умножаем на 4, data.length, то есть длина будет включать все цвета
// поэтому переберать длину массива нужно с шагом в 4 пример:
var imgData = ctx.getImageData(0,0,800,480)// берем кусок
for(var i =0; i < imgData.data.length; i+=4){ // берем каждый пиксель(обрати внимание что
                                             // шаг i+=4 так как в imgData.data.length все цвета)
// вот так работается  со цветами
    for(var j = i; j< i+3; j++){
        imgData.data[j] = 255 - imgData.data[j]; // инверт
    }
// вот так прозрачность. изменяет  альфа-значение прозрачности
    for(var i =3; i < imgData.data.length; i+=4) {
        imgData.data[i] =  imgData.data[i] - 50;
    }
}


putImageData // Помещает на холст объект imageData (содержит RGBA информацию).
//синтаксис
putImageData(imageData, x, y , dX, dY, dWidth, dHeight)
imageData// — объект, созданный с помощью метода createImageData()
            // или полученный с помощью getImageData().
    x,  y // — координаты левого верхнего угла размещаемого
         // на холсте объекта относительно холста;
dX, dY // — координаты левого верхнего угла относительно
       // изображения в imageData, от которого будут рассчитываться размеры изображения;
dWidth, dHeight //— размеры размещаемого объекта
                // (обрезается часть изображения, которая не вмещается в эти размеры).
createImageData //- Создает объект imageData.
    //синтаксис
    createImageData(width, height)
width, height // — размеры создаваемого объекта
//Результатом будет объект imageData с RGBA = (0,0,0,0) и размером width x height


//////////пример:
var imgData = ctx.createImageData(50,50); // Черный квадрат 50 x 50 полностью прозрачный
for(var i=3;i<imgData.data.length;i+=4) {
    imgData.data[i] = 255; // далаем его не прорачным
}
ctx.putImageData(imgData, 20,20); // выводим изображение

/////////////////////////////text////////////////////////////////

ctx.fillText(text, x, y); // рисует (заливает) заданнный текст в заданной позиции (x, y).
                          // Если указан необязательный четвертый параметр, текст будет
                          // масштабироваться в соответветствие с указанной максимальной шириной [, maxWidth]

fontSize = width/2;
ctx.font = fontSize + "px Arial"; // шрифт прописывать обязательно, здесь Arial
ctx.fillStyle = 'white';
ctx.textAlign = "center";
ctx.fillText(cell.value, cell.x + width / 2, cell.y + width / 2 + width/7);
/////////////////////////////gradient////////////////////////////////

// Create gradient
var gradient = ctx.createLinearGradient(0, 0, c.width, 0);
gradient.addColorStop("0", "magenta");
gradient.addColorStop("0.5", "blue");
gradient.addColorStop("1.0", "red");
// Fill with gradient
ctx.fillStyle = gradient;
ctx.fillText("Big smile!", 10, 90);



////////////////////////////////Работа с файлами в JavaScript,///////////////////////////

//Тип File определен в спецификации File API[1] и является абстрактным представлением файла. Каждый экземпляр File имеет следующие свойства:
//name – имя файла
//size – размер файла в байтах
// type –  MIME тип файла

// ПРИМЕР
var fileimg = document.getElementById('header_option-file');
fileimg.onchange = function () { // Когда происходит изменение элементов управления, значит появились новые файлы
    var file = fileimg.files;
    console.log(file);
    console.log("Filename: " + file[0].name);
    console.log("Type: " + file[0].type);
    console.log("Size: " + file[0].size + " bytes");
}

// // ПРИМЕР
var fileimg  = document.getElementById("your-files");
fileimg.addEventListener("change", function(event) {
    // Когда происходит изменение элементов управления, значит появились новые файлы
    var files = fileimg.files;


    for (var i=0; i < files.length; i++) {
        console.log("Filename: " + files[i].name);
        console.log("Type: " + files[i].type);
        console.log("Size: " + files[i].size + " bytes");
    }

}, false);


/////////////////////////////////////////////FileReader///////////////////////////




var fileimg = document.getElementById('header_option-file');
fileimg.onchange = function () {
    var file = fileimg.files[0];  //Эта коллекция FileList, которая представляет собой структуру в виде
    //массива под названием FileList содержащую объекты типа File для
    // каждого выбранного файла в поле <input type="file">
    // +FileList
    //Filename: 2012-Изучаем SQL.pdf
    // Type: application/pdf
    //Size: 16507347 bytes

    var reader = new FileReader();  //   FileReader может представлять данные из файла,
    // формат должен быть задан, когда файл открывается для чтения.
    // Чтение осуществляется с помощью вызова одного из следующих методов:
    //readAsText()  – возвращает содержимое файла как plain text
    //readAsArrayBuffer() – возвращает содержимое файла как ArrayBuffer
    // (хорошо для двоичных данных, например, изображения)
    //readAsDataURL() – возвращает содержимое файла как data URL

    reader.onload = function (event) {
        var contents = event.target.result;  //Результат чтения всегда представлены как event.target.result
        console.log("rrrr " + contents);
    };

    reader.onerror = function (event) {
        console.error(event.target.error.code);
    };
    reader.readAsText(file)
}
//////////////все вместе  and readAsText() //////////////

var fileimg = document.getElementById('header_option-file');
fileimg.onchange = function () {
    var file = fileimg.files[0];
    var reader = new FileReader();
    reader.onload = function (event) {
        var contents = event.target.result;
        console.log("rrrr " + contents);
    };
    reader.onerror = function (event) {
        console.error(event.target.error.code);
    };
    reader.readAsText(file)
}


//////////////readAsDataURL()//////////////////

var fileimg = document.getElementById('header_option-file');
fileimg.onchange = function () {
    var file = fileimg.files[0];
    var reader = new FileReader();
    reader.onload = function (event) {
        var dataUri = event.target.result,
            img = document.createElement("img");
        img.src = dataUri;
        //document.body.appendChild(img);
        console.log(img);
    };

    reader.onerror = function (event) {
        console.error("Файл не может быть прочитан! код " + event.target.error.code);
    };

    reader.readAsDataURL(file);

}
//////////////readAsDataURL()  canvas//////////////////
var fileimg = document.getElementById('header_option-file');
fileimg.onchange = function () {
    var file = fileimg.files[0];
    var reader = new FileReader();
    reader.onload = function (event) {
        var dataUri = event.target.result,
            context = document.getElementById("mycanvas").getContext("2d"),
            img = new Image();

        // ждать, пока изображение не будет полностью обработано
        img.onload = function () {
            context.drawImage(img, 100, 100);
        };
        img.src = dataUri;
    };

    reader.onerror = function (event) {
        console.error("Файл не может быть прочитан! код " + event.target.error.code);
    };

    reader.readAsDataURL(file);
}
///////////////Есть шесть событий прогресса:////////

loadstart     //– указывает что процесс загрузки данных начался.
              // Это событие всегда срабатывает первым
progress      //– срабатывает несколько раз по мере загрузки данных,
// дает доступ к промежуточным данным
error         //–  срабатывает когда загрузка окончилась неудачей
abort        //– срабатывает когда загрузка данных была отменена вызовом метода abort()
             // (такой метод есть и у XMLHttpRequest).
load         //– срабатывает только тогда, когда все данные были успешно загружены
loadend      //– срабатывает, когда объект завершил передачу данных.
// Всегда срабатывает после error, abort или load.
////////////////progress см вверх////////////
//Когда вы хотите отследить прогресс чтения файлов,
// используйте событие progress. Объект event который является параметром этого
// события содержит 3 поля, для контроля передаваемых данных

lengthComputable //– тип boolean указывает может ли браузер определить размер файла
loaded           //– число байтов которые уже загружены
total            //– общее количество байтов которые нужно прочитать


// ПРИМЕР
var fileimg = document.getElementById('header_option-file');
fileimg.onchange = function () {
    var file = fileimg.files[0];
    var reader = new FileReader();

    reader.onprogress = function(event) {
        if (event.lengthComputable) {
            console.log(event.total);
            console.log(event.loaded);
        }
    };

    reader.onloadend = function(event) {
        var contents = event.target.result,
            error = event.target.error;
        if (error != null) {
            console.error("File could not be read! Code " + error.code);
        } else {
            console.log("Contents: " + contents);
        }
    };

    reader.readAsText(file);
}

///////////////////мой скрипт загрузки страницы в канвас//////////////
var fileimg = document.getElementById('header_option-file');
fileimg.onchange = function(){
    var file = fileimg.files[0],
        reader = new FileReader();
    reader.onprogress = function(e){
        if(e.lengthComputable) {
            console.log(e.loaded)
        }
    }
    reader.onload = function(e){
        var resalt = e.target.result,
            can = document.getElementById('canvas-font').getContext("2d"),
            img = new Image();
        img.onload = function (){
            can.drawImage(img, 0 ,0, 800, 480);
        }
        img.src = resalt;



    }
    reader.onerror = function(e){
        console.error("Файл не может быть прочитан! код " + event.target.error.code);
    }
    reader.readAsDataURL(file);

}
///////////////////мой скрипт авто слайдера//////////////
var fileimg = document.getElementById('header_option-file'),
    arfile = [];

fileimg.addEventListener("change", function(event) {
    var reader = new FileReader(),
        file = fileimg.files,
        n = 0;
    reader.onload = function(e){
        var result = e.target.result;

        arfile.push(result);

    }
    function pop(){
        if(arfile.length >= 3){
            var filecan = document.getElementById('canvas-font').getContext('2d');
            var img = new Image();
            img.onload = function(){
                filecan.drawImage(img, 0, 0, 800, 480);
            }
            img.src = arfile[n];
            n++;
            if (n == 3) {
                n = 0;
            }

        }

    }
    setInterval(pop, 1500);
    reader.readAsDataURL(file[0]);
}, false);
////////////////////////////модернизированный скрипт////////////////////////////
var fileimg = document.getElementById('header_option-file'),
    arfile = [],
    div = document.getElementById('page_canvas'),
    n = 0,
    t = 0;
fileimg.addEventListener("change", function(event) {
    var reader = new FileReader(),
        file = fileimg.files;
    reader.onload = function(e){
        if (div.children.length <= 2) {
            var result = e.target.result,
                can = document.createElement('canvas');
            can.width = 350;
            can.height = 200;
            can.setAttribute('class', 'ufa');
            can.setAttribute('id', 'ufa' + n);
            div.appendChild(can);
            arfile.push(result);
            var canufa =  document.getElementById('ufa' + n).getContext('2d'),
                img = new Image();
            img.onload = function(){
                canufa.drawImage(img, 0, 0, 350, 200)
            }
            img.src = arfile[n];
            n++;
            pop();
        }
    }
    function pop(){
        if(arfile.length > 2){
            var  headerfile = document.getElementById('header_option-file'),
                img = new Image(),
                can = document.createElement('canvas');
            headerfile.setAttribute('disabled', '0');

            for(var i = 0; i < 3; i++ ){
                (function(a){
                    setTimeout(function(){
                        var ufa =  document.getElementById('ufa' + a);
                        ufa.remove();
                        if(a == 2){
                            foo();
                        }
                    },1000 * (i + 1))
                })(i)
            }
            can.width = 1080;
            can.height = 600;
            can.setAttribute('id', 'canif');
            div.appendChild(can);
            function foo(){
                setInterval(function(){
                    canif = document.getElementById('canif').getContext('2d');
                    img.onload = function(){
                        canif.drawImage(img, 0, 0, 1080, 600);
                    }
                    img.src = arfile[t];
                    t++;
                    if (t == 3) {
                        t = 0;
                    }
                }, 1000);
            }
        }
    }
    reader.readAsDataURL(file[0]);
}, false);
/////////////////////////////////////переключатель//////////////////////////////////////////
function handl(arr ,classNam){
    for(var i = 0; i<arr.length; i++) {
        arr[i].onmousedown = handeler(arr[i], classNam, arr);
    }
    function handeler(e,classNam, arr){
        return function() {
            for (var a = 0; a < arr.length; a++) {
                arr[a].removeAttribute('class');
            }
            e.setAttribute('class', classNam)
        }
    }
}


;///////////////////// new Image();//////////////////////////////////////////////

img = new Image(); //  Для работы с изображениями в JavaScript используется объект Image
img.src = "http://bezrulya.ru/images/catalog/12000/12697.jpg";
img.width = 100;
img.height = 100;

// ПРИМЕР
var img = new Image(100, 200); // Имеет два необязательных параметра: ширину и высоту:
img.src = 'picture.jpg';
console.log(img);

// <img width="100" height="200" src="picture.jpg">


// ПРИМЕР
var pictures = [];
for (var i = 0; i < 3; i++) {
    pictures[i] = new Image()
    if (i == 0) pictures[i].src = "/pictures/it/javascript/3.gif"
    if (i == 1) pictures[i].src = "/pictures/it/javascript/2.gif"
    if (i == 2) pictures[i].src = "/pictures/it/javascript/1.gif"
}
var n = 0;

function scroll_image() {
    document.images[0].src = pictures[n].src;
    n++;
    if (n == 3) {
        n = 0;
    }
}

setInterval(scroll_image, 1500);

