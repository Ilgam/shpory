//1.Зайдите на официальную страницу скачивания и скачайте  файлы  https://www.mongodb.com/download-center .
// Для разработки можно использовать как 32-, так и 64-разрядную версию.
//
//2.Распакуйте архив (куда угодно) и перейдите в папку bin.

// bsondump: считывает содержимое BSON-файлов и преобразует их в читабельный формат, например, в JSON

//mongo: представляет консольный интерфейс для взаимодействия с базами данных, своего рода консольный клиент
//
//mongod: сервер баз данных MongoDB.
//
//mongodump: утилита создания бэкапа баз данных
//
//mongoexport: утилита для экспорта данных в форматы JSON, TSV или CSV
//
//mongofiles: утилита, позволяющая управлять файлами в системе GridFS
//
//mongoimport: утилита, импорирующая данных в форматах JSON, TSV или CSV в базу данных MongoDB
//
//mongooplog: приложение, позволяющее опрашивать удаленные серверы на наличие операций с
// БД и применять полученные данные к локальному серверу
//
//mongoperf: проверяет производительность жесткого диска на предмет операций ввода-вывода
//
//mongorestore: позволяет записывать данные из дампа, созданного mongodump, в новую или существующую базу данных
//
//mongos: служба маршрутизации MongoDB, которая помогает обрабатывать запросы и определять местоположение данных в кластере MongoDB
//
//mongorestat: представляет счетчики операций с бд
//
//mongotop: предоставляет способ подсчета времени, затраченного на операции чтения-записи в бд

//// Пока ничего не запускайте, но запомните, что mongod — это сервер,
//а mongo — клиентская консоль — вот два исполняемых файла, с которыми нам чаще всего предстоит работать.
//
//3.Создайте новый файл в папке bin и назовите его mongodb.config
//
//4.Добавьте в mongodb.config одну строку: dbpath=ПУТЬ_КУДА_ХОТИТЕ_СОХРАНИТЬ_ФАЙЛЫ_БАЗЫ_ДАННЫХ. Например, в Windows можно написать
//dbpath=c:\mongodb\data а в Linux — dbpath=/etc/mongodb/data.
//
//5.Запустите start mongod с параметром --config mongodb.config.
//
//Теперь, чтобы подключиться к запущенному серверу, можете запустить mongo.
//Попробуйте ввести db.version(), чтобы убедиться, что всё в порядке.
//
//////////////////////////////////////////help или exit
//
//Есть несколько глобальных команд, например help или exit. Команды, которые вы запускаете применительно к текущей базе данных исполняются у
//объекта db, например db.help() или db.stats() . Команды, которые вы запускаете применительно к конкретной коллекции, исполняются у объекта
//db.ИМЯ_КОЛЛЕКЦИИ, например db.unicorns.help() или db.unicorns.count() .
//
//
/////////////////////////////////////////  коллекции(в примере исплользуется колекция learn)
//
//use learn - создать коллекцию learn
//или запустить start mongo learn
//db.createCollection("accounts") - Явное создание коллекции
//
//db.createCollection("profile", {capped:true, size:9500, max: 150}) Ограниченные коллекции
//создадим ограниченную коллекцию с названием profile и зададим для нее размер в 9500 байт
//и количество документов не более 150
//
//db.users.renameCollection("новое_название")  Переименование коллекции
//
//db.stats() - проверка коллекции
//
//db.getCollectionNames() - узнать имя коллекции
//
//db.learn.insert({name: 'Aurora', gender: 'f', weight: 450}) - засунуть в коллекцию
//db.learn.save( { id: "1", name: "Eugene" } ) - или так
//
///////////////////////////////////////Выборка из БД
//
//
//db.learn.find() - вернёт список документов
//{ "_id" : ObjectId("581c6281f0386c93919089ba"), "name" : "Aurora", "gender" : "f", "weight" : 450 }
//Заметьте, что кроме данных, которые мы задавали, появилось дополнительное поле _id
//Каждый документ должен иметь уникальное поле _id
//
//db.users.find({name: "Tom"}, {age: true, _id: false}) выведет имя и возарст, а id не выведет
//
//db.users.find({"company.name": "microsoft"}) Запрос к вложенным объектам
//найдет объект из вот этого
//db.users.insert({"name": "Alex", "age": 28, company: {"name":"microsoft", "country":"USA"}})
//
////////////////////////////////////////Использование JavaScript
//
//fn = function() { return this.name=="Tom"; }
// db.users.find(fn) веногеь те документы, в которых name=Tom.
//
// /////////////////////////////////////// сортировка
//
//db.users.find().limit(3)   Она задает максимально допустимое количество получаемых документов.
//
//db.users.find().skip(3) В данном случае мы получим первые три документа.
//
//db.users.find().sort({name: 1}) сортировать  по возрастанию (1) или по убыванию (-1).
//
//Ну и в конце надо отметить, что мы можем совмещать все эти функции в одной цепочке:
//
//    db.users.find().sort({name: 1}).skip(3).limit(3)
//
//db.users.findOne() найти один элемент

///////////////////////////////////////////////Команды группировки

//db.users.count() можно получить число элементов в коллекции
//
//db.users.find({name: "Tom"}).count() сколько определенных документов, например, у которых name=Tom:
//
//
//Более того мы можем создавать цепочки функций, чтобы конкретизировать условия подсчета:
//    db.users.find({name: "Tom"}).skip(2).count(true)
//Здесь надо отметить, что по умолчанию функция count не используется с функциями limit и skip. Чтобы их использовать,
//    как в примере выше, в функцию count надо передать булевое значение true
//
//db.users.distinct("name")Здесь я запрашиваю только уникальные значения для поля name.
//    И на следующей строке консоль выводит в виде массива найденные уникальные значения.
//    ["Tom", "Bill", "Bob"]
//
//
//
///////////////////////////////////////////////////////////////Группировка и метод group
//
//key: указывает на ключ, по которому надо проводить группировку
//
//initial: представляет базовое значение для сгруппированного результата
//
//reduce: представляет функцию, возвращающую количество элементов. Эта функция принимает в качестве аргументов два параметра: items и prev
//
//keyf: необязательный параметр. Используется вместо параметра key и представляет функцию, которая возвращает объект key
//
//cond: необязательный параметр. Представляет собой условие, которое должно возвращать true, иначе документ не примет участия в группировке.
// Если данный параметр неуказан, то в группировке участвуют все документы
//
//finalize: необязательный параметр. Представляет функцию, которая срабатывает перед тем, как будут возвращены результаты группировки.
//
//
// db.users.group ({key: {name : true}, initial: {total : 0},
//    reduce : function (items,prev){prev.total += 1}})
//
//Параметр key указывает, что группировка будет проводиться по ключу name: key: {name : true}
//Значение параметра initial инициализирует начальное значение поля total. Это поле будет представлять
//количество элементов для группы. И так как элементов может и не быть, то инициализируем нулем.
//
//Параметр reduce представляет функцию, где параметр prev ссылается на предыдущий объект в группе.
//Если найден еще один объект с определенным значением для поля name, то этот документ добавляется в группу,
// а у предыдущего документа в группе извлекается и увеличивается на единицу значение total.
//
/////////////////////////////////////////////Условные операторы в MongoDB
//
//В MongoDB в запросах можно использовать условные конструкции с помощью операторов сравнения:
//
//$gt (больше чем)
//
//$lt (меньше чем)
//
//$gte (больше или равно)
//
//$lte (меньше или равно)
//
//Например, найдем все документы, у которых значение ключа age меньше 30:
//
//
//db.users.find ({age: {$lt : 30}})
//Аналогично будет использование других операторов сравнения. Например, тот же ключ, только больше 30:
//
//
// db.users.find ({age: {$gt : 30}})
//
//
//
////////////////////////////////////////////////Обновление данных
//
//
// функция update. Она принимает три параметра:
//
//query: принимает запрос на выборку документа, который надо обновить
//
//objNew: представляет документ с новой информацией, который заместит старый при обновлении
//
//options: определяет дополнительные параметры при обновлении документов. Может принимать два аргумента: upsert и multi.
//
//    Если параметр upsert имеет значение true, что mongodb будет обновлять документ, если он найден, и создавать новый,
//    если такого документа нет. Если же он имеет значение false, то mongodb не будет создавать новый документ, если
//запрос на выборку не найдет ни одного документа.
//
//    Параметр multi указывает, должен ли обновляться первый элемент в выборке (используется по умолчанию, если данный параметр не указан)
//или же должны обновляться все документы в выборке.
//
//db.users.update({name : "Tom"}, {name: "Tom", age : 25, married : false}, {upsert: true})
//Теперь документ, найденный запросом {name : "Tom"}, будет перезаписан документом {"name": "Tom", "age" :"25", "married" : false}.
//
//
//db.users.update({name : "Eugene", age: 29}, {$set: {age : 30}})   $set -обновление отдельного поля  Если документ не содержит обновляемое поле,
//                                                                   то оно создается.
//
//В данном случае обновлялся только один документ, первый в выборке. Указав значение multi:true, мы можем обновить все документы выборки:
//    db.users.update({name : "Tom"}, {$set: {name: "Tom", age : 25, married : false}}, {multi:true})
//
//
// db.users.update({name : "Tom"}, {$inc: {salary:100}}) $inc увеличения значения числового поля
//
// db.users.update({name : "Tom"}, {$unset: {salary: 1}})Удаление поля
//
// db.users.update({name : "Tom"}, {$push: {languages: "russian"}}) $push позволяет добавить еще одно значение к уже существующему.
//Если ключ, для которого мы хотим добавить значение, не представляет массив, то мы получим ошибку Cannot apply $push/$pushAll modifier to non-array.
//
//Оператор $addToSet подобно оператору $push добавляет объекты в массив. Отличие состоит в том, что $addToSet добавляет данные,
//если их еще нет в массиве:
// db.users.update({name : "Tom"}, {$addToSet: {languages: "russian"}})
//Используя оператор $each, можно добавить сразу несколько значений:
//db.users.update({name : "Tom"}, {$addToSet: {languages: {$each: ["russian", "spanish", "italian"]}}})
//
//
//db.users.update({name : "Tom"}, {$pop: {languages: 1}}) Оператор $pop позволяет удалять элемент из массива
//Указывая для ключа languages значение 1, мы удаляем первый элемент с конца. Чтобы удалить первый элемент сначала
//массива, надо передать отрицательное значение:
//
// db.users.update({name : "Tom"}, {$pop: {languages: -1}})
//
//А если мы хотим удалить не одно значение, а сразу несколько, тогда мы можем применить оператор $pullAll:
//db.users.update({name : "Tom"}, {$pullAll: {languages: ["english", "german", "french"]}})



///////////////////////////////////////////Работа с индексами

//db.users.createIndex({"name" : 1}) createIndex устанавливается индекс по полю name. MongoDB позволяет
// установить до 64 индексов на одну коллекцию.

//Если мы просто определим индекс для коллекции, например, db.users.createIndex({"name" : 1}), то
// мы все еще сможем добавлять в коллекцию документы с одинаковым значением ключа name. Однако, если нам потребуется,
//чтобы в коллекцию можно было добавлять документ с одним и тем же значением ключа только один раз, мы можем установить флаг unique:
// db.users.createIndex({"name" : 1}, {"unique" : true})
//Теперь, если мы попытаемся добавить в коллекцию два документа с одним и тем же значением name, то мы получим ошибку.

//Все индексы базы данных хранятся в системной коллекции system.indexes.
//    Обратившись к ней, мы можем получить все индексы и связанную с ними информацию:
//
//
// db.system.indexes.find()
//Также мы можем воспользоваться методом getIndexes и вывести всю информацию об индексах для конкретной коллекции:
//
//db.users.getIndexes()
//
//db.users.dropIndex("name_1")  удаления индекса


//////////////////////////////////////////// удаления документов


//Для удаления документов в MongoDB предусмотрен метод remove:
//
//db.users.remove({name : "Tom"})
//
//Метод remove() возвращает объект WriteResult. При успешном удалении одного документа результат будет следующим
//
//WriteResult({"nRemoved" : 1})
//
//В итоге все найденные документы с name=Tom будут удалены. Причем, как и в случае с find,
//мы можем задавать условия выборки для удаления различными способами
//(в виде регулярных выражений, в виде условных конструкций и т.д.):
//
// db.users.remove({name : /T\w+/i})
// db.users.remove({age: {$lt : 30}})
//
//Метод remove также может принимать второй необязательный параметр булевого типа, который указывает,
//надо удалять один элемент или все элементы, соответствующие условию. Если этот параметр равен true,
// то удаляется только один элемент. По умолчанию он равен false:
//
//db.users.remove({name : "Tom"}, true)
//
//Чтобы удалить разом все документы из коллекции, надо оставить пустым параметр запроса:
//
//db.users.remove({})
//
//Удаление коллекций и баз данных
//
//Мы можем удалять не только документы, но и коллекции и базы данных. Для удаления коллекций используется функция drop:
//
//    db.users.drop()
//
//И если удаление коллекции пройдет успешно, то консоль выведет:
//
//    true
//
//Чтобы удалить всю базу данных, надо воспользоваться функцией dropDatabase():
//
// db.dropDatabase()




